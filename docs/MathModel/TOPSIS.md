## 引子

为什么不直接使用层次分析法？

即：层次分析法的局限性：

（1）评价的决策层不能太多，太多的话n会很大，怕判断矩阵和一致矩阵差异性可能会很大

（2）如果决策层中指标的数据已知，如何利用这些数据使得评价更加准确？--分析数据内在特征来进行建模。

## TOPSIS优劣解距离法

### 构造计算评分的公式

**例如：**学生成绩评分：

| 学生编号 | 成绩 |
| :------: | :--: |
|    A     |  89  |
|    B     |  60  |
|    C     |  74  |
|    D     |  99  |

为四名同学进行评分，能合理描述成绩的高低；

（下面的评分可类比于层次分析法的权重）

| 学生编号 | 成绩 | 排名 | 修正后的排名 |   评分   |
| :------: | :--: | :--: | :----------: | :------: |
|    A     |  89  |  2   |      3       | 3/10=0.3 |
|    B     |  60  |  4   |      1       | 1/10=0.1 |
|    C     |  74  |  3   |      2       | 2/10=0.2 |
|    D     |  99  |  1   |      4       | 4/10=0.4 |

上表的评分具有不合理之处，例如，将B和D的成绩修改成10和90、A和C修改成80和70，也不会对评分产生任何影响。即：可以随意修改成绩，只要保证排名不变，评分也不会发生改变。

一个比较好的方法，可以一定程度上修正：记$G（Goal）$为成绩，$G_{max}$为最高成绩，$G_{min}$为最低成绩

构造计算评分的公式：$F(G)=\frac{G-G_min}{G_{max}-G_{min}}\sim U(G_{min},G_{max})$服从均匀分布。

| 学生编号 | 成绩 |    未归一化的评分    |  归一化评分   |
| :------: | :--: | :------------------: | :-----------: |
|    A     |  89  | (89-60)/(99-60)=0.74 | 0.74/2.1=0.35 |
|    B     |  60  |  (60-60)/(99-60)=0   |    0/2.1=0    |
|    C     |  74  | (74-60)/(99-60)=0.36 | 0.36/2.1=0.17 |
|    D     |  99  |  (99-60)/(99-60)=1   |  1//2.1=0.48  |



**为甚不使用卷面最大值减去卷面最小值即$\frac{G-0}{100-0}$来作为构造评分的公式呢？**

给出以下三点解释：

1. 比较的对象一般要远大于两个。 (例如比较一个班级的成绩)
2. **比较的指标也往往不只是一个方面的**，例如成绩、工时数、课外竞赛得分等。
3. **有很多指标不存在理论上的最大值和最小值**，例如衡量经济增长水平的指标: GDP增速。



**因此，构造计算评分的公式：**
$$
F(G)=\frac{G-G_{min}}{G_{max}-G_{min}} \sim U(G_{min},G_{max})
$$


### 数据正向化与统一指标类型

常见的四个指标：

|       指标类型       |     评判标准     |        适用范举例        |
| :------------------: | :--------------: | :----------------------: |
| 极大型（效益型）指标 |  越大（多）越好  | 成绩、GDP增速、企业利润  |
| 极小型（成本型）指标 |  越小（少）越好  |  费用、坏品率、污染程度  |
|      中间型指标      | 越接近某个值越好 |    水质量评估时的PH值    |
|      区间型指标      | 落在某个区间最好 | 体温、水中植物性营养物量 |

现在新增加一个指标，要综合评价四位同学，并为他们进行评分：

| 学生编号 | 成绩 | 处分次数 |
| :------: | :--: | :------: |
|    A     |  89  |    2     |
|    B     |  60  |    0     |
|    C     |  74  |    1     |
|    D     |  99  |    3     |

成绩是**越高（大）越好**，这样的指标称为**极大型指标（效益性指标）**；处分次数**越少（小）越好**，这样的指标称为**极小型指标（成本型指标）**。

在指标的好坏评判标度方向参差的情况下，不方便进行评判，因此需要统一指标类型。

**最常用的方法是：指标正向化**，即将所有指标转化为极大型指标。极小型指标向极大型指标转化的公式是$G_{max}-G$，如下表：

| 学生编号 |  成绩  | 处分次数  | 正向化后的处分次数 |
| :------: | :----: | :-------: | :----------------: |
|    A     |   89   |     2     |      Gmax-2=1      |
|    B     |   60   | 0（Gmin） |      Gmax-0=3      |
|    C     |   74   |     1     |         =2         |
|    D     |   99   | 3（Gmax） |         =0         |
| 指标类型 | 极大型 |  极小型   |       极大型       |

#### 标准化处理

为了**消去不同标量纲的影响**，需要对已经正向化的矩阵进行标准化处理。

<img src="http://www.yqys-space.top/wp-content/uploads/2024/01/TOPSIS_biaozhunhuachuli.png" style="zoom: 50%;" />

只有一个指标时，构造计算评分的公式：

$$
F(G)=\frac{G-G_min}{G_{max}-G_{min}}\sim U(G_{min},G_{max})
$$
变形=$F(G)=\frac{G-G_min}{G_{max}-G_{min}}=\frac{G-G_min}{(G_{max}-G)+(G-G_{min})}$

可看作：

$$
\frac{G与最小值的距离}{G与最大值的距离+G与最小值的距离}
$$
当有多个指标时，需要找到每个指标（每列）的最小值和最大值，将所有最小值构造出一个向量、所有最大值构造出一个向量，如下图：

![](http://www.yqys-space.top/wp-content/uploads/2024/01/TOPSIS_duozhibiao.png)

### 如何计算得分

| 学生编号 | 成绩 | 标准化成绩 | 标准化正向化后处分次数 |
| :------: | :--: | :--------: | :--------------------: |
|    A     |  89  |   0.5437   |         0.2673         |
|    B     |  60  |   0.3665   |         0.8018         |
|    C     |  74  |   0.4520   |         0.5345         |
|    D     |  99  |   0.6048   |           0            |

最大值：[0.6048,0.8018]，最小值：[0.3665,0];

$D_A^+=\sqrt{(0.6048-0.5437)^2+(0.8018-0.2673)^2}=0.5380$

$D_A^-=\sqrt{(0.3665-0.5437)^2+(0-0.2673)^2}=0.3206$

$D_B^+=\sqrt{(0.6048-0.3665)^2+(0.8018-0.8018)^2}=0.2382$

$D_B^-=\sqrt{(0.3665-0.3665)^2+(0-0.8108)^2}=0.8108$

同理，算出其余同学的得分；



## TOPSIS–代码部分

**下面要介绍的是TOPSIS的代码书写方法，TOPSIS总体分为三步：**
**1、矩阵正向化**
**2、正向化矩阵标准化**
**3、计算评分并归一化**
下面根据这三步开始我们的代码编写：

### 第一步：导入数据

把数据复制到工作区，并将这个矩阵命名为x
① 在工作区右键，点击新建（ctrl+n），输入变量名称X
② 在Excel中复制数据，再回到X变量中粘贴数据
③ 右键X另存为，保存为mat文件，以后调用X只需要用load命令即可加载数据（这里我保存的mat文件命名为X.mat）
④ 代码和数据需要放在同一个目录下哦

### 第二步：判断是否需要正向化，并进行正向化

```matlab
clear all
clc
%%  导入数据
% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X
% （2）双击进入X，输入或拷贝数据到X
% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件
% （4）注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。
load data_water_quality.mat

%%  数据预处理_正向化
[n,m] = size(X);
disp(['共有' num2str(n) '个评价对象, ' num2str(m) '个评价指标']) 
Judge = input(['这' num2str(m) '个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  ']);

if Judge == 1
    Position = input('请输入需要正向化处理的指标所在的列，例如[2,3,6]： '); %[2,3,4]
    disp('请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） ')
    Type = input('例如[1,3,2]：  '); %[2,1,3]
    % 注意，Position和Type是两个同维度的行向量
    for i = 1 : size(Position,2)%对每一列进行正向化处理
        X(:,Position(i)) = Positivization(X(:,Position(i)),Type(i),Position(i));
    % 第一个参数是要正向化处理的那一列向量 X(:,Position(i))
    % 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）
    % 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列
    % 返回值返回正向化之后的指标
    end
    disp('正向化后的矩阵 X =  ')
    disp(X)
end

%% 数据预处理_标准化
Z = X ./ repmat(sum(X.*X) .^ 0.5, n, 1);
disp('标准化矩阵 Z = ')
disp(Z)

%% 指标权重赋值
disp("请输入是否需要增加权重向量，需要输入1，不需要输入0")
Judge = input('请输入是否需要增加权重： ');
if Judge == 1
    disp(['有多少个指标就输入多少个权重数(权重和为1)，如[0.25,0.25,0.5]']);
    weigh = input(['请输入输入' num2str(m) '个权重: ']);
        if abs(sum(weigh) - 1)<0.000001 && size(weigh,1) == 1 && size(weigh,2) == m   % 这里要注意浮点数的运算是不精准的。
        else
            weigh = input('你输入的有误，请重新输入权重行向量: ');
        end
else
    weigh = ones(1,m) ./ m ; %如果不需要加权重就默认权重都相同，即都为1/m
end

%% 计算与最大值的距离和最小值的距离，并算出得分
D_P = sum([(Z - repmat(max(Z),n,1)) .^ 2 ] .* repmat(weigh,n,1) ,2) .^ 0.5;   % D+ 与最大值的距离向量
D_N = sum([(Z - repmat(min(Z),n,1)) .^ 2 ] .* repmat(weigh,n,1) ,2) .^ 0.5;   % D- 与最小值的距离向量
S = D_N ./ (D_P+D_N);    % 未归一化的得分
disp('最后的得分为：')
stand_S = S / sum(S)% 归一化的得分
[sorted_S,index] = sort(stand_S ,'descend')%对得分进行排序并返回原来的位置
plot(sorted_S,'r-o')
xmin=1;xmax = size(sorted_S,1);
ymin = 0;ymax = max(sorted_S)+min(sorted_S);
axis([xmin xmax ymin ymax]); % 设置坐标轴在指定的区间
grid on
xlabel('方案');ylabel('分数');%坐标轴表示对bai象标签
title('TOPSIS算法最终评分排序')
```

接下来开始定义我们的Positivization函数，函数不可以直接放在主函数中，和大多数语言不同，函数需要在matlab中单独定义一个m文件，并且函数文件需要和主函数放在同一个目录，也就是同一个文件夹当中。首先定义三种指标的转化函数：

### **极小型转化为极大型**：**Min2Max**

```matlab
%function[输出变量]=函数名（输入变量）
%函数最后需要用end结尾
function[posit_x]=Min2Max(x)
	posit_x=max(x)-x;
end
```

### **中间型转化为极大型：Mid2Max**

```matlab
function[posit_x]=Mid2Max(x,best)
	M=max(abs(x-best));
	posit_x=1-abs(x-best)/M;
end
```

### **区间型指标转化为极大型指标:Inter2Max**

 M=max{a-min{xi},max{xi}-b}

```matlab
function[posit_x]=Inter2Max(x,a,b)
	r_x=size(x,1);%表示列向量的行数（row of x)，来找到循环的次数
	M=max([a-min(x),max(x)-b]);
	posit_x=zeros(r_x,1) %将posit_x初始化为一个全为0的列向量
	for i=1:r_x
		if x(i)<a
			posit_x(i)=1-(a-x(i)/M;
		elseif x(i)>b
			posit_x(i)=1-(x(i)-b)/M;
		else
			posit_x(i)=1;
		end
	end
end
```



### 正向化处理函数Positivization.m程序

```matlab
function [posit_x] = Positivization(x,type,i)
% 输入变量有三个：
% x：需要正向化处理的指标对应的原始列向量
% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）
% i: 正在处理的是原始矩阵中的哪一列
% 输出变量posit_x表示：正向化后的列向量
    if type == 1  %极小型
        disp(['第' num2str(i) '列是极小型，正在正向化'] )
        posit_x = Min2Max(x);  %调用Min2Max函数来正向化
        disp(['第' num2str(i) '列极小型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    elseif type == 2  %中间型
        disp(['第' num2str(i) '列是中间型'] )
        best = input('请输入最佳的那一个值(中间的那个值)： ');
        posit_x = Mid2Max(x,best);
        disp(['第' num2str(i) '列中间型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    elseif type == 3  %区间型
        disp(['第' num2str(i) '列是区间型'] )
        a = input('请输入区间的下界： ');
        b = input('请输入区间的上界： '); 
        posit_x = Inter2Max(x,a,b);
        disp(['第' num2str(i) '列区间型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    else
        disp('没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值')
    end
end
```

